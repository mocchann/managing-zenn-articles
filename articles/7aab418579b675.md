---
title: "ã€é–¢æ•°å‹ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã€‘TypeScriptã§æ›¸ã„ã¦ã¿ãŸ"
emoji: "ğŸ“"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["TypeScript", "Fsharp", "DDD"]
published: false
---

:::message
ã“ã®è¨˜äº‹ã¯ã€ãƒ—ãƒ­ã‚‚ããƒãƒ£ãƒƒãƒˆ Advent Calendar 2024ã€‘ã®8æ—¥ç›®ã§ã™
:::

https://qiita.com/advent-calendar/2024/puromoku

## ã¯ã˜ã‚ã«
ä»Šå¹´ã®å¤ã”ã‚ã«ä»¥ä¸‹æ›¸ç±ãŒç™ºå£²ã•ã‚Œã¾ã—ãŸ

https://asciidwango.jp/post/754242099814268928/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0

DDDã‚’å­¦ã¶ãŸã‚ã«æ‰‹ã«å–ã£ãŸæ›¸ç±ã ã£ãŸã®ã§ã™ãŒã€F#ã§æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’TypeScriptã«æ›¸ãç›´ã—ãªãŒã‚‰å­¦ç¿’ã‚’é€²ã‚ãŸã®ã§è¨˜äº‹ã«ã¾ã¨ã‚ã‚ˆã†ã¨æ€ã„ã¾ã™

## é–¢æ•°å‹ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã£ã¦ã©ã‚“ãªæ›¸ç±
é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®è¦–ç‚¹ã‹ã‚‰DDDã‚’è§£èª¬ã—ãŸæ›¸ç±ã§ã™
æƒ³å®šèª­è€…ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™(æ›¸ç±ã‹ã‚‰å¼•ç”¨)

> - å‹ã¨é–¢æ•°ã—ã‹ä½¿ã‚ãšã«ã€ã©ã†ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã—å®Ÿè£…ã§ãã‚‹ã‹ã«èˆˆå‘³ãŒã‚ã‚‹æ–¹
> - ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆã‚’ç°¡æ½”ã«æŠŠæ¡ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘è¨­è¨ˆã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆè¨­è¨ˆã¨ã©ã†é•ã†ã®ã‹ã‚’å­¦ã³ãŸã„æ–¹
> - ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆã®çµŒé¨“è€…ã§ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãŒDDDã«ã©ã†å½¹ç«‹ã¤ã®ã‹ã‚’å­¦ã³ãŸã„æ–¹
> - é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ã¤ã„ã¦å­¦ã³ãŸã„ãŒã€ç†è«–ã‚„æŠ½è±¡åŒ–ãŒå¤šéãã¦æ•¬é ã—ã¦ã„ã‚‹æ–¹
> - F#ã¨é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãŒç¾å®Ÿçš„ãªãƒ‰ãƒ¡ã‚¤ãƒ³ã«ã©ã†é©ç”¨ã§ãã‚‹ã®ã‹ã‚’è¦‹ã¦ã¿ãŸã„æ–¹

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¯F#ã§è¨˜è¿°ã•ã‚Œã¦ãŠã‚Šã€å°è¦æ¨¡è£½é€ ä¼šç¤¾ã®ã€Œå—æ³¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®è‡ªå‹•åŒ–ã€ã‚’ä¾‹ã«æˆ¦ç•¥çš„DDDã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§è§£èª¬ãŒé€²ã‚“ã§ã„ãã¾ã™

## ã“ã®è¨˜äº‹ã®ã‚´ãƒ¼ãƒ«

:::message
**é–¢æ•°å‹DDDã‚’TypeScriptã§ã©ã®ã‚ˆã†ã«å®Ÿè£…ã§ãã‚‹ã®ã‹ã®ä¸€ä¾‹ã‚’çŸ¥ã‚‹ã“ã¨**
:::

## å®Ÿéš›ã«æ›¸ã„ãŸã‚³ãƒ¼ãƒ‰

ã§ã¯æ—©é€ŸTypeScriptã§å®Ÿè£…ã—ãŸã‚³ãƒ¼ãƒ‰ãŒã“ã¡ã‚‰ã§ã™(é•·ã„ã®ã§ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã§)

:::details ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
```TypeScript
import {
  fromPromise,
  ok,
  okAsync,
  Result,
  ResultAsync,
  safeTry,
} from "neverthrow";

import {
  Address,
  CustomerInfo,
  EmailAddress,
  FirstName,
  HtmlString,
  LastName,
  OrderAcknowledgment,
  OrderId,
  OrderQuantity,
  PersonalName,
  Price,
  ProductCode,
  SendOrderAcknowledgment,
  UnvalidatedAddress,
  UnvalidatedAmountToBill,
  UnvalidatedBillingAddress,
  UnvalidatedCustomerInfo,
  UnvalidatedOrderLine,
  UnvalidatedShippingAddress,
  ValidatedOrderLine,
} from "./simpleTypes";

export const PlaceOrderWorkflow = () => {
  // ====================
  // ãƒ‘ãƒ¼ãƒˆ1: è¨­è¨ˆ
  // ====================

  // ----- æ³¨æ–‡ã®æ¤œè¨¼ -----

  type CheckProductCodeExists = (productCode: ProductCode) => boolean;
  type CheckedAddress = { type: "checkedAddress"; address: Address };

  type Uri = string;
  type ServiceInfo = {
    name: string;
    endpoint: Uri;
  };
  type Exception = string;
  type RemoteServerError = {
    service: ServiceInfo;
    exception: Exception;
  };
  type CheckAddressExists = (
    unvalidatedAddress: UnvalidatedAddress
  ) => ResultAsync<CheckedAddress, Error>;

  type UnvalidatedOrder = {
    orderId: string;
    customerInfo: UnvalidatedCustomerInfo;
    shippingAddress: UnvalidatedShippingAddress;
    billingAddress: UnvalidatedBillingAddress;
    orderLines: UnvalidatedOrderLine[];
    amountToBill: UnvalidatedAmountToBill;
  };

  type ValidatedOrder = {
    orderId: OrderId;
    customerInfo: CustomerInfo;
    shippingAddress: Address;
    billingAddress: Address;
    orderLines: ValidatedOrderLine[];
  };

  type ValidationError = { type: "error"; error: string };
  type ValidateOrder = (
    checkProductCodeExists: CheckProductCodeExists // ä¾å­˜é–¢ä¿‚
  ) => (
    unvalidatedOrder: UnvalidatedOrder // å…¥åŠ›
  ) => ResultAsync<ValidatedOrder, ValidationError>; // å‡ºåŠ›

  // ----- æ³¨æ–‡ã®ä¾¡æ ¼æ±ºå®š -----

  type GetProductPrice = (productCode: ProductCode) => Price;
  type CreateOrderAcknowledgmentLetter = (
    pricedOrder: PricedOrder
  ) => HtmlString;

  type PricingError = { type: "error"; error: string };
  type PriceOrder = (
    getProductPrice: GetProductPrice
  ) => (validatedOrder: ValidatedOrder) => Result<PricedOrder, PricingError>;

  type PlaceOrderEvent =
    | { type: "orderPlaced"; orderPlaced: OrderPlaced }
    | { type: "billableOrderPlaced"; billableOrderPlaced: BillableOrderPlaced }
    | {
        type: "orderAcknowledgmentSent";
        acknowledgmentSent: OrderAcknowledgmentSent;
      };
  type Command<Data> = {
    data: Data;
    timestamp: Date;
    userId: string;
    // etc
  };
  type PlaceOrderCommand = Command<UnvalidatedOrder>;
  type PlaceOrderWorkflow = (
    placeOrderCommand: PlaceOrderCommand // å…¥åŠ›ã‚³ãƒãƒ³ãƒ‰
  ) => ResultAsync<PlaceOrderEvent[], PlaceOrderError>; // å‡ºåŠ›ã‚¤ãƒ™ãƒ³ãƒˆ

  type ValidatedCustomerInfo = CustomerInfo;
  type ValidatedShippingAddress = Address;
  type ValidatedBillingAddress = Address;
  type PricedOrderLine = {
    orderLineId: string;
    productCode: ProductCode;
    quantity: OrderQuantity;
    linePrice: Price;
  };
  type BillingAmount = Price;

  // ä¾¡æ ¼è¨ˆç®—æ¸ˆã¿ã®æ³¨æ–‡ã®å‹
  type PricedOrder = {
    orderId: OrderId;
    customerInfo: ValidatedCustomerInfo;
    shippingAddress: ValidatedShippingAddress;
    billingAddress: ValidatedBillingAddress;
    // æ¤œè¨¼æ¸ˆã¿ã®æ³¨æ–‡æ˜ç´°è¡Œã¨ã¯ç•°ãªã‚Šã€OrderLineâ†’PricedOrderLineã«å¤‰æ›´
    orderLines: PricedOrderLine[];
    amountToBill: BillingAmount;
  };

  /// å—æ³¨ç¢ºå®šãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®æˆåŠŸå‡ºåŠ›
  type OrderPlaced = PricedOrder;
  type BillableOrderPlaced = {
    orderId: OrderId;
    billingAddress: Address;
    amountToBill: BillingAmount;
  };
  type OrderAcknowledgmentSent = {
    orderId: OrderId;
    emailAddress: EmailAddress;
  };

  type AcknowledgeOrder = (
    createOrderAcknowledgmentLetter: CreateOrderAcknowledgmentLetter // ä¾å­˜é–¢ä¿‚
  ) => (
    sendOrderAcknowledgment: SendOrderAcknowledgment // ä¾å­˜é–¢ä¿‚
  ) => (
    pricedOrder: PricedOrder // å…¥åŠ›
  ) => OrderAcknowledgmentSent | undefined; // å‡ºåŠ›

  // å—æ³¨ç¢ºå®šãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å¤±æ•—å‡ºåŠ›
  type PlaceOrderError =
    | { type: "validation"; error: ValidationError }
    | { type: "pricing"; error: PricingError }
    | { type: "remoteServiceError"; error: RemoteServerError }
    | { type: "createEventsError"; error: CreateEventsError };

  type CreateEventsError = { type: "error"; error: string };

  type CreateEvents = (
    pricedOrder: PricedOrder // å…¥åŠ›
  ) => (
    orderAcknowledgmentSent?: OrderAcknowledgmentSent // å…¥åŠ›(å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã®ã‚¤ãƒ™ãƒ³ãƒˆ)
  ) => PlaceOrderEvent[]; // å‡ºåŠ›

  // ====================
  // ãƒ‘ãƒ¼ãƒˆ2: å®Ÿè£…
  // ====================

  // ====================
  // æ³¨æ–‡ã®æ¤œè¨¼: å®Ÿè£…
  // ====================

  const toCustomerInfo = (
    unvalidatedCustomerInfo: UnvalidatedCustomerInfo
  ): CustomerInfo => {
    const firstName: FirstName = unvalidatedCustomerInfo.firstName;
    const lastName: LastName = unvalidatedCustomerInfo.lastName;
    const emailAddress: EmailAddress = unvalidatedCustomerInfo.emailAddress;
    const name: PersonalName = {
      firstName,
      lastName,
    };

    const customerInfo: CustomerInfo = {
      name,
      emailAddress,
    };

    return customerInfo;
  };

  const toAddress = (
    checkedAddress: CheckedAddress
  ): ResultAsync<Address, ValidationError> => {
    const result: Address = {
      addressLine1: checkedAddress.address.addressLine1,
      addressLine2: checkedAddress.address.addressLine2,
      addressLine3: checkedAddress.address.addressLine3,
      addressLine4: checkedAddress.address.addressLine4,
      city: checkedAddress.address.city,
      zipCode: checkedAddress.address.zipCode,
    };

    return okAsync(result);
  };

  const predicateToPassthru =
    (errorMsg: string) => (f: CheckProductCodeExists) => (x: ProductCode) => {
      if (f(x)) {
        return x;
      } else {
        throw new Error(errorMsg);
      }
    };

  const toProductCode =
    (checkProductCodeExists: CheckProductCodeExists) =>
    (productCode: ProductCode) => {
      const checkProduct = (productCode: ProductCode): ProductCode => {
        const errorMsg = `Invalid: ${productCode}`;
        return predicateToPassthru(errorMsg)(checkProductCodeExists)(
          productCode
        );
      };
      return checkProduct(productCode);
    };

  const toOrderQuantity =
    (productCode: ProductCode) =>
    (quantity: OrderQuantity): OrderQuantity => {
      const createUnitQuantity = (unitQuantity: OrderQuantity): number => {
        if (unitQuantity.type === "unitQuantity") {
          return unitQuantity.unitQuantity;
        } else {
          throw new Error("Invalid unit quantity");
        }
      };

      const createKilogramQuantity = (kiloQuantity: OrderQuantity): number => {
        if (kiloQuantity.type === "kilogramQuantity") {
          return kiloQuantity.kilogramQuantity;
        } else {
          throw new Error("Invalid kilogram quantity");
        }
      };

      const createOrderQuantity = (
        quantity: number,
        type: string
      ): OrderQuantity => {
        return type === "widgetCode"
          ? { type: "unitQuantity", unitQuantity: quantity }
          : { type: "kilogramQuantity", kilogramQuantity: quantity };
      };

      switch (productCode.type) {
        case "widgetCode":
          const unitQuantity = createUnitQuantity(quantity);
          return createOrderQuantity(unitQuantity, "widgetCode");
        case "gizmoCode":
          const kilogramQuantity = createKilogramQuantity(quantity);
          return createOrderQuantity(kilogramQuantity, "gizmoCode");
        default:
          throw new Error("Unknown product code");
      }
    };

  const toValidatedOrderLine =
    (checkProductCodeExists: CheckProductCodeExists) =>
    (unvalidatedOrderLine: UnvalidatedOrderLine): ValidatedOrderLine => {
      const orderLineId = unvalidatedOrderLine.orderLineId;
      const productCode = toProductCode(checkProductCodeExists)(
        unvalidatedOrderLine.productCode
      ); // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°(toProductCode)
      const quantity = toOrderQuantity(productCode)(
        unvalidatedOrderLine.quantity
      ); // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°(toOrderQuantity)

      const validatedOrderLine: ValidatedOrderLine = {
        orderLineId,
        productCode,
        quantity,
      };

      return validatedOrderLine;
    };

  /// æ³¨æ–‡ã®æ¤œè¨¼ã‚¹ãƒ†ãƒƒãƒ—ã®å®Ÿè£…

  const validateOrder: ValidateOrder =
    (checkProductCodeExists: CheckProductCodeExists) =>
    (unvalidatedOrder: UnvalidatedOrder) => {
      return safeTry(async function* () {
        const create = (value: string): OrderId => ({ value });
        const orderId: OrderId = create(unvalidatedOrder.orderId);

        const customerInfo: CustomerInfo = toCustomerInfo(
          unvalidatedOrder.customerInfo
        );

        const checkedShippingAddress = yield* toCheckedAddress(
          checkAddressExistsR
        )(unvalidatedOrder.shippingAddress).safeUnwrap();

        // ResultAsync<T, E>ã®Tã ã‘ã‚’å¾—ãŸã„ãŸã‚ã€yield* safeUnwrap()ã‚’ä½¿ã£ã¦å–å¾—ã™ã‚‹
        const shippingAddress = yield* toAddress(
          checkedShippingAddress
        ).safeUnwrap();

        const checkedBillingAddress = yield* toCheckedAddress(
          checkAddressExistsR
        )(unvalidatedOrder.billingAddress).safeUnwrap();

        // ResultAsync<T, E>ã®Tã ã‘ã‚’å¾—ãŸã„ãŸã‚ã€yield* safeUnwrap()ã‚’ä½¿ã£ã¦å–å¾—ã™ã‚‹
        const billingAddress = yield* toAddress(
          checkedBillingAddress
        ).safeUnwrap();

        const orderLines = unvalidatedOrder.orderLines.map(
          toValidatedOrderLine(checkProductCodeExists)
        );

        const validatedOrder: ValidatedOrder = {
          orderId,
          customerInfo,
          shippingAddress,
          billingAddress,
          orderLines,
        };

        return ok(validatedOrder);
      });
    };

  // Priceã«æ•°é‡ã‚’æ›ã‘åˆã‚ã›ã‚‰ã‚Œã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  const multiply = (p: Price, qty: OrderQuantity): Price => {
    return qty.type === "unitQuantity"
      ? p * qty.unitQuantity
      : p * qty.kilogramQuantity;
  };

  // æ¤œè¨¼æ¸ˆã¿ã®æ³¨æ–‡æ˜ç´°è¡Œã‚’ä¾¡æ ¼è¨ˆç®—æ¸ˆã¿ã®æ³¨æ–‡æ˜ç´°è¡Œã«å¤‰æ›ã™ã‚‹
  const toPricedOrderLine =
    (getProductPrice: GetProductPrice) =>
    (line: ValidatedOrderLine): PricedOrderLine => {
      const qty = line.quantity;
      const price = getProductPrice(line.productCode);
      const linePrice = multiply(price, qty);

      return {
        orderLineId: line.orderLineId,
        productCode: line.productCode,
        quantity: line.quantity,
        linePrice,
      };
    };

  // ä¾¡æ ¼ãƒªã‚¹ãƒˆã‚’åˆè¨ˆã—ã¦è«‹æ±‚ç·é¡ã«ã™ã‚‹
  // åˆè¨ˆãŒç¯„å›²å¤–ã®å ´åˆã¯ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã‚‹
  const sumPrices = (prices: Price[]) => {
    const total = prices.reduce((total, price) => total + price, 0);
    return total;
  };

  // ä¾¡æ ¼è¨ˆç®—ã‚¹ãƒ†ãƒƒãƒ—ã®å®Ÿè£…
  const priceOrder: PriceOrder = (getProductPrice) => (validatedOrder) => {
    const lines = validatedOrder.orderLines.map(
      toPricedOrderLine(getProductPrice)
    );
    const amountToBill = sumPrices(lines.map((line) => line.linePrice));

    const pricedOrder: PricedOrder = {
      orderId: validatedOrder.orderId,
      customerInfo: validatedOrder.customerInfo,
      shippingAddress: validatedOrder.shippingAddress,
      billingAddress: validatedOrder.billingAddress,
      orderLines: lines,
      amountToBill,
    };

    return ok(pricedOrder);
  };

  // ç¢ºèªã‚¹ãƒ†ãƒƒãƒ—ã®å®Ÿè£…
  const acknowledgeOrder: AcknowledgeOrder =
    (createAcknowledgmentLetter) =>
    (sendOrderAcknowledgment) =>
    (pricedOrder): OrderAcknowledgmentSent | undefined => {
      const letter = createAcknowledgmentLetter(pricedOrder);
      const acknowledgment: OrderAcknowledgment = {
        emailAddress: pricedOrder.customerInfo.emailAddress,
        letter,
      };

      // é€ä¿¡ãŒæˆåŠŸã—ãŸå ´åˆã¯OrderAcknowledgmentSentã‚’è¿”ã™
      // å¤±æ•—ã—ãŸå ´åˆã¯Noneã‚’è¿”ã™
      const sendResult = sendOrderAcknowledgment(acknowledgment);
      switch (sendResult.type) {
        case "Sent":
          const event: OrderAcknowledgmentSent = {
            orderId: pricedOrder.orderId,
            emailAddress: pricedOrder.customerInfo.emailAddress,
          };
          return event;
        case "NotSent":
          return undefined;
      }
    };

  type Some<T> = { type: "Some"; value: T };
  type None = { type: "None" };
  type Option<T> = Some<T> | None;
  // ã‚ªãƒ—ã‚·ãƒ§ãƒ³å‹ã‚’ãƒªã‚¹ãƒˆå‹ã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  const listOfOption = (opt?: Option<PlaceOrderEvent>): PlaceOrderEvent[] => {
    switch (opt?.type) {
      case "Some":
        return [opt.value];
      case "None":
        return [];
      default:
        return [];
    }
  };

  const createBillingEvent =
    (pricedOrder: PricedOrder) => (): Option<BillableOrderPlaced> => {
      const BillingAmount = pricedOrder.amountToBill;
      if (BillingAmount > 0) {
        const order = {
          orderId: pricedOrder.orderId,
          billingAddress: pricedOrder.billingAddress,
          amountToBill: pricedOrder.amountToBill,
        };
        return { type: "Some", value: order };
      }
      return { type: "None" };
    };

  const createEvents: CreateEvents =
    (pricedOrder) =>
    (acknowledgmentEventOpt?): PlaceOrderEvent[] => {
      const event: PlaceOrderEvent = {
        type: "orderPlaced",
        orderPlaced: pricedOrder,
      };
      const event1 = listOfOption({ type: "Some", value: event });

      const event20pt = acknowledgmentEventOpt
        ? {
            type: "orderAcknowledgmentSent" as const,
            acknowledgmentSent: acknowledgmentEventOpt,
          }
        : undefined;

      const event2 = event20pt
        ? listOfOption({ type: "Some", value: event20pt })
        : [];

      const event30pt = (() => {
        const billingEvent = createBillingEvent(pricedOrder)();
        if (billingEvent.type === "Some") {
          return {
            type: "billableOrderPlaced" as const,
            billableOrderPlaced: billingEvent.value,
          };
        }
        return undefined;
      })();

      const event3 = event30pt
        ? listOfOption({ type: "Some", value: event30pt })
        : [];

      return [...event1, ...event2, ...event3];
    };

  const serviceExceptionAdapter = <T, E, X>(
    serviceInfo: ServiceInfo,
    fService: (x: X) => ResultAsync<T, E>
  ): ((x: X) => ResultAsync<T, RemoteServerError>) => {
    return (x: X) => {
      const result = fService(x);
      const mappedResult = result.mapErr((error) => {
        const remoteServerError: RemoteServerError = {
          service: serviceInfo,
          exception: `${error}`,
        };
        return remoteServerError;
      });
      return mappedResult;
    };
  };

  // bind: Result<T>ã¨(T) => Result<U>ã‚’ä½¿ã£ã¦ã€Result<U>ã‚’æ‰‹ã«ã„ã‚Œã‚‹

  const checkAddressExists: CheckAddressExists = (
    unvalidatedAddress: UnvalidatedAddress
  ) => {
    // Result<Response>
    const r1 = fromPromise(
      fetch("https://example.com/address-service/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(unvalidatedAddress),
      }),
      () => Error("Address Validation Error")
    );

    // Result<Response> to Result<Address>
    const r2 = r1.andThen((r1) => {
      const r2 = fromPromise(r1.json() as Promise<Address>, () =>
        Error("FooError")
      );

      return r2;
    });

    // Result<Address> to Result<CheckedAddress>
    const r3 = r2.map((address) => {
      const x: CheckedAddress = {
        type: "checkedAddress",
        address,
      };

      return x;
    });

    return r3;
  };

  const checkAddressExistsR = (
    unvalidatedAddress: UnvalidatedAddress
  ): ResultAsync<CheckedAddress, RemoteServerError> => {
    const serviceInfo: ServiceInfo = {
      name: "AddressService",
      endpoint: "https://example.com/address-service/",
    };

    const adaptedService = serviceExceptionAdapter(
      serviceInfo,
      checkAddressExists
    );

    return adaptedService(unvalidatedAddress);
  };

  const toCheckedAddress =
    (
      checkAddressExistsR: (
        unvalidatedAddress: UnvalidatedAddress
      ) => ResultAsync<CheckedAddress, RemoteServerError>
    ) =>
    (unvalidatedAddress: UnvalidatedAddress) => {
      const result = checkAddressExistsR(unvalidatedAddress);
      return result.mapErr((error) => {
        const validationError: ValidationError = {
          type: "error",
          error: `${error}`,
        };
        return validationError;
      });
    };

  // ====================
  // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å…¨ä½“åƒ
  // ====================

  const placeOrder =
    (checkProductCodeExists: CheckProductCodeExists) =>
    (getProductPrice: GetProductPrice) =>
    (createOrderAcknowledgmentLetter: CreateOrderAcknowledgmentLetter) =>
    (sendOrderAcknowledgment: SendOrderAcknowledgment): PlaceOrderWorkflow => {
      return (placeOrderCommand: PlaceOrderCommand) => {
        // DI
        const fValidateOrder = validateOrder(checkProductCodeExists);
        const fPricedOrder = priceOrder(getProductPrice);
        const fAcknowledgmentOption = acknowledgeOrder(
          createOrderAcknowledgmentLetter
        )(sendOrderAcknowledgment);
        const fCreateEvents = createEvents;

        const validateOrderAdapted = (unvalidatedOrder: UnvalidatedOrder) => {
          // å¼•æ•°ã‚’å—ã‘å–ã£ã¦ã€å®Ÿè¡Œçµæœã®Errorã‚’åˆ¥ã®ã‚¨ãƒ©ãƒ¼ã«å¤‰æ›ã—ãŸé–¢æ•°ã‚’å¾—ãŸã„
          const fResult = fValidateOrder(unvalidatedOrder);
          const result = fResult.mapErr((error) => {
            const placeOrderError: PlaceOrderError = {
              type: "validation",
              error: error,
            };

            return placeOrderError;
          });

          return result;
        };
        const priceOrderAdapted = (
          aValidatedOrder: ValidatedOrder
        ): Result<PricedOrder, PlaceOrderError> => {
          const result = fPricedOrder(aValidatedOrder).mapErr((error) => {
            const placeOrderError: PlaceOrderError = {
              type: "pricing",
              error: error,
            };

            return placeOrderError;
          });

          return result;
        };

        // exec
        const aValidatedOrder = validateOrderAdapted(placeOrderCommand.data);
        const aPricedOrder = aValidatedOrder.andThen(priceOrderAdapted);
        const acknowledgedOption = aPricedOrder.map(fAcknowledgmentOption);
        return safeTry(async function* () {
          const aPricedOrderResult = yield* (await aPricedOrder).safeUnwrap();
          const acknowledgedOptionResult = yield* (
            await acknowledgedOption
          ).safeUnwrap();

          return ok(
            fCreateEvents(aPricedOrderResult)(acknowledgedOptionResult)
          );
        });
      };
    };
};
```
:::

æ™®æ®µæ¥­å‹™ã§TypeScriptã‚’è§¦ã£ã¦ã„ã‚‹æ–¹ã§ã‚‚è¦‹æ…£ã‚Œãªã„ã‚³ãƒ¼ãƒ‰ã«ãªã£ã¦ã„ã‚‹ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ
é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ã„ã†ã“ã¨ã§ã€é–¢æ•°ã®ã‚«ãƒªãƒ¼åŒ–ã‚„Resultå‹ã®å°å…¥ã€ãƒ¢ãƒŠãƒ‰ã®è€ƒãˆæ–¹ã«ã‚ˆã£ã¦ã‚³ãƒ¼ãƒ‰ãŒå®Ÿè£…ã•ã‚Œã¦(ã„ã‚‹ã‚‰ã—ã„)ã„ã¾ã™

ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å…¨ä½“ã¯ã“ã¡ã‚‰
https://github.com/mocchann/domain_modeling_functional/tree/main/src

## é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’TypeScriptã§å®Ÿè£…ã™ã‚‹ã¾ã§ã®æˆ¦ã„ã®éæ­´

å®Ÿã¯ç¾åœ¨ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã«æ·»ä»˜ã—ã¦ã„ã‚‹ã‚‚ã®ãŒã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®æœ€çµ‚ç³»ã§ã€ãã‚Œä»¥å‰ã«ä½•åº¦ã‚‚æ›¸ãç›´ã—ã‚’è¡Œã£ã¦ã„ã¾ã™
(ãƒ•ã‚¡ã‚¤ãƒ«ã®å‘½åã¯é©å½“ã§ã™ãŒ)ä»¥ä¸‹ãƒ•ã‚¡ã‚¤ãƒ«ã®é †ç•ªã§å®Ÿè£…ã‚’ä¿®æ­£ã—ãŸã‚Šã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å°å…¥ã—ãŸã‚Šã—ã¦é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¡¨ç¾ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™
â€»æœ€çµ‚ç³»ã¯5ã®placeOrderWorkflowFixToAddress.tsã§ã™

:::message
1. placeOrderWorkflowFirst.ts
2. placeOrderWorkflowSecond
3. placeOrderWorkflowErrorHandling.ts
4. placeOrderWorkflowNeverThrow.ts
5. placeOrderWorkflowFixToAddress.ts
:::

ã“ã“ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«å·®åˆ†ã‚’é †ç•ªã«è¦‹ã¦ã„ãå½¢ã§é€²ã‚ã¾ã™

### placeOrderWorkflowFirst.ts <-> placeOrderWorkflowSecond.ts

ã¾ãšæœ€åˆã«å®Ÿè£…ã—ãŸã‚³ãƒ¼ãƒ‰ãŒplaceOrderWorkflowFirst.tsã§ã™
åˆæœŸã®å®Ÿè£…ã§ã¯ã‚«ãƒªãƒ¼åŒ–ã•ã‚ŒãŸé–¢æ•°ã«ã‚ˆã£ã¦ä¾å­˜æ€§æ³¨å…¥ã¨å®Ÿè¡ŒãŒæ··ã–ã£ãŸçŠ¶æ…‹ã§ã‚³ãƒ¼ãƒ‰ãŒæ›¸ã‹ã‚Œã¦ãŠã‚Šã€ã¨ã¦ã‚‚è¦–èªæ€§ãŒæ‚ªã‹ã£ãŸã®ã§DIã¨Executeã«ã‚ã‘ã‚‹ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã„ã¾ã—ãŸ

```diff ts:placeOrderWorkflow.ts
  // ====================
  // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å…¨ä½“åƒ
  // ====================

  const placeOrder =
    (checkProductCodeExists: CheckProductCodeExists) =>
    (checkAddressExists: CheckAddressExists) =>
    (getProductPrice: GetProductPrice) =>
    (createOrderAcknowledgmentLetter: CreateOrderAcknowledgmentLetter) =>
    (sendOrderAcknowledgment: SendOrderAcknowledgment): PlaceOrderWorkflow => {
      return async (placeOrderCommand: PlaceOrderCommand) => {
-       const validatedOrder = await validateOrder(checkProductCodeExists)(
-          checkAddressExists
-       )(placeOrderCommand.data);
-
-       const pricedOrder = priceOrder(getProductPrice)(validatedOrder);
-
-       const acknowledgmentOption = acknowledgeOrder(
-         createOrderAcknowledgmentLetter
-       )(sendOrderAcknowledgment)(pricedOrder);
+       // DI
+       const fValidatedOrder = validateOrder(checkProductCodeExists)(
+         checkAddressExists
+       );
+       const fPricedOrder = priceOrder(getProductPrice);
+       const fAcknowledgmentOption = acknowledgeOrder(
+         createOrderAcknowledgmentLetter
+       )(sendOrderAcknowledgment);
+
+       // exec
+       const validatedOrder = await fValidatedOrder(placeOrderCommand.data);
+       const pricedOrder = fPricedOrder(validatedOrder);
+       const acknowledgmentOption = fAcknowledgmentOption(pricedOrder);

        const events = createEvents(pricedOrder)(acknowledgmentOption);

        return { success: true, value: events };
      };
    };
```

Firstã¨Secondã®å·®åˆ†ã¯ã“ã‚Œã ã‘ã§ã™

### placeOrderWorkflowSecond.ts <-> placeOrderWorkflowErrorHandling
æ¬¡ã«Resultå‹ã‚’ä½¿ã£ã¦ã‚¨ãƒ©ãƒ¼ã‚’æ˜ç¤ºã™ã‚‹ã‚ˆã†ã«å®Ÿè£…ä¿®æ­£ãƒ»è¿½åŠ ã‚’è¡Œã„ã¾ã—ãŸ
â€»é€šå¸¸ã®é–¢æ•°ã‚’1æœ¬ã®ç·šè·¯ã ã¨ã™ã‚‹ã¨ã€Resultå‹ã‚’å‡ºåŠ›ã™ã‚‹é–¢æ•°ã¯2ã¤(æˆåŠŸ or å¤±æ•—)ã«åˆ†ã‹ã‚Œã‚‹ç·šè·¯ã ã¨ã„ã†ã‚¤ãƒ¡ãƒ¼ã‚¸ã¨è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™(ä»¥ä¸‹æ›¸ç±ã‚’å‚è€ƒã«ä½œæˆã—ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ãŒä»¥ä¸‹)
è‘—è€…ã¯ã“ã‚Œã‚’ã€Œé‰„é“æŒ‡å‘ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã€ã¨è¡¨ç¾ã—ã¦ã„ã¾ã™

![alt text](</images/7aab418579b675/result.png>)

â€»ã“ã®ã‚ˆã†ãªé–¢æ•°ã®ã“ã¨ã‚’é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ä¸–ç•Œã§ã¯ã€Œãƒ¢ãƒŠãƒ‡ã‚£ãƒƒã‚¯é–¢æ•°ã€ã¨å‘¼ã¶ãã†ã§ã™

```diff ts:placeOrderWorkflow.ts
  // ====================
  // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å…¨ä½“åƒ
  // ====================

  const placeOrder =
    (checkProductCodeExists: CheckProductCodeExists) =>
-   (checkAddressExists: CheckAddressExists) =>
    (getProductPrice: GetProductPrice) =>
    (createOrderAcknowledgmentLetter: CreateOrderAcknowledgmentLetter) =>
    (sendOrderAcknowledgment: SendOrderAcknowledgment): PlaceOrderWorkflow => {
      return async (placeOrderCommand: PlaceOrderCommand) => {
        // DI
-       const fValidatedOrder = validateOrder(checkProductCodeExists)(
-         checkAddressExists
-       );
+       const fValidateOrder = validateOrder(checkProductCodeExists);
        const fPricedOrder = priceOrder(getProductPrice);
        const fAcknowledgmentOption = acknowledgeOrder(
          createOrderAcknowledgmentLetter
        )(sendOrderAcknowledgment);
+       const fCreateEvents = createEvents;
+
+       const validateOrderAdapted = async (
+         unvalidatedOrder: UnvalidatedOrder
+       ) => {
+         return mapError(
+           (fValidateOrder: ValidationError) => ({
+             type: "validation" as const,
+             error: fValidateOrder,
+           }),
+           await fValidateOrder(unvalidatedOrder)
+         );
+       };
+       const priceOrderAdapted = (aValidatedOrder: ValidatedOrder) => {
+         return mapError(
+           (fPricedOrder: PricingError) => ({
+             type: "pricing" as const,
+             error: fPricedOrder,
+           }),
+           fPricedOrder(aValidatedOrder)
+         );
+       };

        // exec
-       const validatedOrder = await fValidatedOrder(placeOrderCommand.data);
-       const pricedOrder = fPricedOrder(validatedOrder);
-       const acknowledgmentOption = fAcknowledgmentOption(pricedOrder);
-
-       const events = createEvents(pricedOrder)(acknowledgmentOption);
-
-       return { success: true, value: events };
+       const aValidatedOrder = await validateOrderAdapted(
+         placeOrderCommand.data
+       );
+       const aPricedOrder = bind(aValidatedOrder, priceOrderAdapted);
+       const acknowledgedOption = map(aPricedOrder, fAcknowledgmentOption);
+
+       if (aPricedOrder.type === "error") {
+         return { type: "error", error: aPricedOrder.error };
+       }
+
+       const events = map(
+         acknowledgedOption,
+         fCreateEvents(aPricedOrder.value)
+       );
+
+       return events;
      };
    };

+   const mapError = <T, E, F>(
+     f: (error: E) => F,
+     aResult: Result<T, E>
+   ): Result<T, F> => {
+     switch (aResult.type) {
+       case "ok":
+         return { type: "ok", value: aResult.value };
+       case "error":
+         return { type: "error", error: f(aResult.error) };
+     }
+   };
+ 
+   const bind = <T, E1, E2, U>(
+     result: Result<T, E1>,
+     f: (value: T) => Result<U, E2>
+   ): Result<U, E1 | E2> => {
+     switch (result.type) {
+       case "ok":
+         return f(result.value);
+       case "error":
+         return result;
+     }
+   };
+ 
+   const map = <T, E, U>(
+     result: Result<T, E>,
+     f: (value: T) => U
+   ): Result<U, E> => {
+     switch (result.type) {
+       case "ok":
+         return { type: "ok", value: f(result.value) };
+       case "error":
+         return result;
+     }
+   };
```

å·®åˆ†ãŒå¤šã„ãŸã‚ã€ä¸Šè¨˜ã¯å¤‰æ›´ã—ãŸã‚³ãƒ¼ãƒ‰ã®ä¸€éƒ¨ã‚’è¨˜è¼‰ã—ã¦ã„ã¾ã™
å…¨å®Ÿè£…ã¯GitHubã®ä»¥ä¸‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–²è¦§ãã ã•ã„

https://github.com/mocchann/domain_modeling_functional/blob/main/src/placeOrderWorkflowErrorHandling.ts

ã¾ãŸã€ã“ã®å®Ÿè£…ã§ã¯Resultå‹ã‚’ç”¨ã„ã¦ã„ã‚‹ãŸã‚ã€é–¢æ•°ã®å‡ºåŠ›ã¯æˆåŠŸ or å¤±æ•—ã®2ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæƒ³å®šã•ã‚Œã¾ã™
ã“ã®ãƒ¢ãƒŠãƒ‡ã‚£ãƒƒã‚¯é–¢æ•°åŒå£«ã®å…¥å‡ºåŠ›ã‚’1ã¤ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«åˆæˆã™ã‚‹ãŸã‚ã«ã€ã€ŒmapError/bind/mapã€ã¨ã„ã†3ã¤ã®é–¢æ•°ã‚’ä½œæˆã—ã¦ã„ã¾ã™(æ›¸ç±ã‚’å‚è€ƒã«ä½œæˆã—ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ãŒä»¥ä¸‹)

![alt text](</images/7aab418579b675/resultMap.png>)

æ›¸ç±ã§ã¯ã“ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ä¸Šéƒ¨ã®çŸ¢å°ã‚’ã€ŒæˆåŠŸãƒˆãƒ©ãƒƒã‚¯ã€ã€ã‚¤ãƒ¡ãƒ¼ã‚¸ä¸‹éƒ¨ã®åˆ†å²ã—ãŸçŸ¢å°ã‚’ã€Œå¤±æ•—ãƒˆãƒ©ãƒƒã‚¯ã€ã¨å‘¼ã‚“ã§ã„ã¾ã™

> ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«å‹ãŒå¤‰ã‚ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹æˆåŠŸãƒˆãƒ©ãƒƒã‚¯ã¨ã¯ç•°ãªã‚Šã€ã‚¨ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒã‚¯ã§ã¯ã€ãƒˆãƒ©ãƒƒã‚¯ã«æ²¿ã£ã¦ãšã£ã¨å‡ä¸€ãªå‹ãŒã‚ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å†…ã®ã™ã¹ã¦ã®é–¢æ•°ã¯ã€**åŒã˜**ã‚¨ãƒ©ãƒ¼å‹ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

ã“ã®å¼•ç”¨ã®ã‚¨ãƒ©ãƒ¼å‹ã‚’æº€ãŸã™ãŸã‚ã®é–¢æ•°ã¨ã—ã¦mapErrorã‚’ä½œæˆã—ã¦ã„ã¾ã™
ã“ã‚Œã¯`Result<T, E>`ã‚’`Result<T, F>`ã«å¤‰æ›ã™ã‚‹é–¢æ•°ã§ã™

```TypeScript
const mapError = <T, E, F>(
    f: (error: E) => F,
    aResult: Result<T, E>
  ): Result<T, F> => {
    switch (aResult.type) {
      case "ok":
        return { type: "ok", value: aResult.value };
      case "error":
        return { type: "error", error: f(aResult.error) };
    }
  };
```

å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹é–¢æ•°ã«ã¯bindä½¿ã„ã¾ã™
bindã¯`Result<T, E1>ã¨(T) => Result<U, E2>`ã‚’ä½¿ã£ã¦ã€`Result<U, E1 | E2>`ã‚’æ‰‹ã«ã„ã‚Œã¾ã™

```TypeScript
const bind = <T, E1, E2, U>(
    result: Result<T, E1>,
    f: (value: T) => Result<U, E2>
  ): Result<U, E1 | E2> => {
    switch (result.type) {
      case "ok":
        return f(result.value);
      case "error":
        return result;
    }
  };
```

å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒãªã„é–¢æ•°ã«ã¯mapã‚’ä½¿ã£ã¦ã€`Result<T, E>`ã‚’`Result<U, E>`ã«å¤‰æ›ã—ã¾ã™

```TypeScript
const map = <T, E, U>(
    result: Result<T, E>,
    f: (value: T) => U
  ): Result<U, E> => {
    switch (result.type) {
      case "ok":
        return { type: "ok", value: f(result.value) };
      case "error":
        return result;
    }
  };
```

ã“ã®ã‚ˆã†ãªå®Ÿè£…ã‚’ã™ã‚‹ã¨ãã®æ€è€ƒæ‰‹é †ã¯ä»¥ä¸‹ã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã™ã‚‹ã¨ã‚ã‹ã‚Šã‚„ã™ã‹ã£ãŸã§ã™

:::message
`ResultAsync<T, E>`ã‚’`ResultAsync<A, E>`ã«ã—ãŸã„ã¨ã

- å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹â†’bindã‚’ä½¿ã†
- å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒãªã„â†’mapã‚’ä½¿ã†

:::

ã“ã®æ€è€ƒæ‰‹é †ã‚’å…ƒã«ã‚‚ã†ä¸€åº¦å®Ÿè£…ã‚’è¦‹ã¦ã¿ã¾ã™(NOTEã§èª¬æ˜ã‚’è¿½åŠ )

```TypeScript
  const placeOrder =
    (checkProductCodeExists: CheckProductCodeExists) =>
    (getProductPrice: GetProductPrice) =>
    (createOrderAcknowledgmentLetter: CreateOrderAcknowledgmentLetter) =>
    (sendOrderAcknowledgment: SendOrderAcknowledgment): PlaceOrderWorkflow => {
      return async (placeOrderCommand: PlaceOrderCommand) => {
        // DI
        const fValidateOrder = validateOrder(checkProductCodeExists);
        const fPricedOrder = priceOrder(getProductPrice);
        const fAcknowledgmentOption = acknowledgeOrder(
          createOrderAcknowledgmentLetter
        )(sendOrderAcknowledgment);
        const fCreateEvents = createEvents;

        // NOTE: fValidateOrderã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ã¾ãšmapErrorã§ã‚¨ãƒ©ãƒ¼å‹ã‚’ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å…±é€šã®ã‚¨ãƒ©ãƒ¼å‹ã«å¤‰æ›ã™ã‚‹
        const validateOrderAdapted = async (
          unvalidatedOrder: UnvalidatedOrder
        ) => {
          return mapError(
            (fValidateOrder: ValidationError) => ({
              type: "validation" as const,
              error: fValidateOrder,
            }),
            await fValidateOrder(unvalidatedOrder)
          );
        };
        // NOTE: fPriceOrderã‚‚å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€mapErrorã«é€šã—ã¦ã‚¨ãƒ©ãƒ¼å‹ã‚’å…±é€šã®ã‚¨ãƒ©ãƒ¼å‹ã«å¤‰æ›ã™ã‚‹
        const priceOrderAdapted = (aValidatedOrder: ValidatedOrder) => {
          return mapError(
            (fPricedOrder: PricingError) => ({
              type: "pricing" as const,
              error: fPricedOrder,
            }),
            fPricedOrder(aValidatedOrder)
          );
        };

        // exec
        // NOTE: validateOrderAdaptedã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ã¯ã‚ã‚‹ãŒã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æœ€åˆã®é–¢æ•°ãªã®ã§bindã¯é€šã•ãšãã®ã¾ã¾å®Ÿè¡Œã—ã¦çµæœã‚’å¾—ã‚‹
        const aValidatedOrder = await validateOrderAdapted(
          placeOrderCommand.data
        );
        // NOTE: priceOrderAdaptedã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€ã‹ã¤å…¥åŠ›ãŒResult<æˆåŠŸ, å¤±æ•—>ã®2ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãŸã‚bindã‚’ä½¿ã†
        const aPricedOrder = bind(aValidatedOrder, priceOrderAdapted);
        // NOTE: å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒãªã„ãŸã‚mapã‚’ä½¿ç”¨
        const acknowledgedOption = map(aPricedOrder, fAcknowledgmentOption);

        if (aPricedOrder.type === "error") {
          return { type: "error", error: aPricedOrder.error };
        }

        // NOTE: å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒãªã„ãŸã‚mapã‚’ä½¿ç”¨
        const events = map(
          acknowledgedOption,
          fCreateEvents(aPricedOrder.value)
        );

        return events;
      };
    };
```

ã“ã®æ€è€ƒæ‰‹é †ã§è€ƒãˆã‚‹ã¨å®Ÿè£…ã®é€²ã‚æ–¹ãŒå°‘ã—ã‚¤ãƒ¡ãƒ¼ã‚¸ã—ã‚„ã™ããªã‚‹ã‹ã¨æ€ã„ã¾ã™

ã“ã®ã‚ˆã†ã«bindã¨mapã‚’ç”¨ã„ã‚‹ã“ã¨ã§ã€placeOrderã®å‡¦ç†ã«ç‰¹åˆ¥ãªæ¡ä»¶åˆ†å²ã‚„try/catchãƒ–ãƒ­ãƒƒã‚¯ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ãªãã‚¯ãƒªãƒ¼ãƒ³ãªçŠ¶æ…‹ã‚’ä¿ã¤ã“ã¨ãŒã§ãã‚‹ã¨æ›¸ç±ã§ã¯èª¬æ˜ã•ã‚Œã¦ã„ã¾ã™
(ä¸€éƒ¨æ¡ä»¶åˆ†å²ãŒå…¥ã‚Šè¾¼ã‚“ã§ã„ã¾ã™ãŒã“ã‚Œã¯å¾Œç¶šã®å‡¦ç†ã§ä¿®æ­£ã—ã¾ã™)

### placeOrderWorkflowErrorHandling <-> placeOrderWorkflowNeverThrow
æ¬¡ã¯å®Ÿè£…ãŒå¤§ããå¤‰ã‚ã£ã¦ã„ãã¾ã™
ã•ãã»ã©å®Ÿè£…ã—ãŸResultå‹, bind, map, mapErrorãªã©TypeScriptã§ã¯è¨€èªæ¨™æº–ã¨ã—ã¦æº–å‚™ã•ã‚Œã¦ã„ãªã„ãŸã‚ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã—ãŸã„ã¨ãã«æ¯å›è‡ªå‰ã§å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
ã“ã‚Œã‚’è‰¯ã„æ„Ÿã˜ã«æä¾›ã—ã¦ãã‚Œã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«neverthrowãŒã‚ã‚‹ã®ã§ã“ã¡ã‚‰ã‚’ä½¿ã£ã¦ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã„ã¾ã—ãŸ

https://github.com/supermacro/neverthrow

```diff ts:placeOrderWorkflow.ts
import { fromPromise, ok, Result, ResultAsync, safeTry } from "neverthrow";

  // ====================
  // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å…¨ä½“åƒ
  // ====================

  const placeOrder =
    (checkProductCodeExists: CheckProductCodeExists) =>
    (getProductPrice: GetProductPrice) =>
    (createOrderAcknowledgmentLetter: CreateOrderAcknowledgmentLetter) =>
    (sendOrderAcknowledgment: SendOrderAcknowledgment): PlaceOrderWorkflow => {
-     return async (placeOrderCommand: PlaceOrderCommand) => {
+     return (placeOrderCommand: PlaceOrderCommand) => {
        // DI
        const fValidateOrder = validateOrder(checkProductCodeExists);
        const fPricedOrder = priceOrder(getProductPrice);
        const fAcknowledgmentOption = acknowledgeOrder(
          createOrderAcknowledgmentLetter
        )(sendOrderAcknowledgment);
        const fCreateEvents = createEvents;

-       const validateOrderAdapted = async (
-         unvalidatedOrder: UnvalidatedOrder
-       ) => {
-         return mapError(
-           (fValidateOrder: ValidationError) => ({
-             type: "validation" as const,
-             error: fValidateOrder,
-           }),
-           await fValidateOrder(unvalidatedOrder)
-         );
+       const validateOrderAdapted = (unvalidatedOrder: UnvalidatedOrder) => {
+         const fResult = fValidateOrder(unvalidatedOrder);
+         const result = fResult.mapErr((error) => {
+           const placeOrderError: PlaceOrderError = {
+             type: "validation",
+             error: error,
+           };
+
+           return placeOrderError;
+         });
+
+         return result;
        };

        // exec
-       const aValidatedOrder = await validateOrderAdapted(
-         placeOrderCommand.data
-       );
-       const aPricedOrder = bind(aValidatedOrder, priceOrderAdapted);
-       const acknowledgedOption = map(aPricedOrder, fAcknowledgmentOption);
-
-       if (aPricedOrder.type === "error") {
-         return { type: "error", error: aPricedOrder.error };
-       }
-
-       const events = map(
-         acknowledgedOption,
-         fCreateEvents(aPricedOrder.value)
-       );
-
-       return events;
+       const aValidatedOrder = validateOrderAdapted(placeOrderCommand.data);
+       const aPricedOrder = aValidatedOrder.andThen(priceOrderAdapted);
+       const acknowledgedOption = aPricedOrder.map(fAcknowledgmentOption);
+       return safeTry(async function* () {
+         const aPricedOrderResult = yield* (await aPricedOrder).safeUnwrap();
+         const acknowledgedOptionResult = yield* (
+           await acknowledgedOption
+         ).safeUnwrap();
+
+         return ok(
+           fCreateEvents(aPricedOrderResult)(acknowledgedOptionResult)
+         );
+       });
      };
    };
  };

- const mapError = <T, E, F>(
-   f: (error: E) => F,
-   aResult: Result<T, E>
- ): Result<T, F> => {
-   switch (aResult.type) {
-     case "ok":
-       return { type: "ok", value: aResult.value };
-     case "error":
-       return { type: "error", error: f(aResult.error) };
-   }
- };
-
- const bind = <T, E1, E2, U>(
-   result: Result<T, E1>,
-   f: (value: T) => Result<U, E2>
- ): Result<U, E1 | E2> => {
-   switch (result.type) {
-     case "ok":
-       return f(result.value);
-     case "error":
-       return result;
-   }
- };
-
- const map = <T, E, U>(
-   result: Result<T, E>,
-   f: (value: T) => U
- ): Result<U, E> => {
-   switch (result.type) {
-     case "ok":
-       return { type: "ok", value: f(result.value) };
-     case "error":
-       return result;
-   }
- };
```

ä¸Šè¨˜ã‚³ãƒ¼ãƒ‰ã®importã‚’è¦‹ã‚Œã°ã‚ã‹ã‚‹ã‚ˆã†ã«è‡ªå‰ã§å®Ÿè£…ã—ã¦ã„ãŸResultå‹ã€AsyncResultå‹ãŒãã‚Œãã‚Œneverthrowã®Result, ResultAsyncã«ç½®ãæ›ãˆã‚‰ã‚Œã¦ã„ã¾ã™
ã“ã®å‹ã¯ãã‚Œãã‚ŒandThen(bind), map(map), mapErr(mapError)ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚ã€è‡ªå‰ã§ç”¨æ„ã—ãŸé–¢æ•°ã¯å¿…è¦ãªããªã‚Šã¾ã—ãŸ

â€»ä¸Šè¨˜ã‚³ãƒ¼ãƒ‰ã‚‚å·®åˆ†ãŒå¤šã„ãŸã‚ã€å…¨ã‚³ãƒ¼ãƒ‰ç¢ºèªã—ãŸã„æ–¹ã¯ä»¥ä¸‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–²è¦§ãã ã•ã„
https://github.com/mocchann/domain_modeling_functional/blob/main/src/placeOrderWorkflowNeverThrow.ts

ã¾ãŸä»–ã«ã‚‚`safeTry`ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã‚Šã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å†…ã«å­˜åœ¨ã—ã¦ã„ãŸæ¡ä»¶åˆ†å²ã‚‚è¨˜è¿°ã™ã‚‹å¿…è¦ãŒãªããªã£ã¦ã„ã¾ã™

```diff ts:safeTrySample.ts
-       if (aPricedOrder.type === "error") {
-         return { type: "error", error: aPricedOrder.error };
-       }
-
-       const events = map(
-         acknowledgedOption,
-         fCreateEvents(aPricedOrder.value)
-       );
-
-       return events;
+       return safeTry(async function* () {
          // NOTE: ResultAsync<T, E>ã®Tã ã‘ã‚’å¾—ãŸã„ãŸã‚ã€yield* safeUnwrap()ã‚’ä½¿ã£ã¦ResultAsync<T>ã ã‘ã‚’å–å¾—ã™ã‚‹
+         const aPricedOrderResult = yield* (await aPricedOrder).safeUnwrap();
+         const acknowledgedOptionResult = yield* (
+           await acknowledgedOption
+         ).safeUnwrap();
+
+         return ok(
+           fCreateEvents(aPricedOrderResult)(acknowledgedOptionResult)
+         );
+       });
```

aPricedOrderã®å‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ãŠã‚Šã€æ¡ä»¶åˆ†å²ã‚’çµã‚Šè¾¼ã¿ã‚’è¡Œã†ç­‰ã‚’ã—ãªã„ã¨é–¢æ•°ã®åˆæˆãŒã§ãã¾ã›ã‚“ã§ã—ãŸ

```TypeScript
const aPricedOrder: Result<PricedOrder, {
    type: "validation";
    error: ValidationError;
} | {
    type: "pricing";
    error: PricingError;
}>
```

ãã“ã§ã¾ãšandThenã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®å‹ã®çµæœã‚’å¾—ãŸã‚ã¨ã€safeTryã®ä¸­ã§yield* safeUnwrap()ã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã‚Šã€æˆåŠŸãƒˆãƒ©ãƒƒã‚¯ã®ã¿ã‚’å–å¾—ã™ã‚‹ã“ã¨ã§é–¢æ•°ã®åˆæˆã‚’å¯èƒ½ã«ã—ã¦ã„ã¾ã™

```TypeScript
const aValidatedOrder: ResultAsync<ValidatedOrder, {
    type: "validation";
    error: ValidationError;
}>
```

ã¾ã•ã«TypeScriptã§é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’è¡Œã†ãŸã‚ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™

### placeOrderWorkflowNeverThrow <-> placeOrderWorkflowFixToAddress
æœ€å¾Œã¯ä¸€éƒ¨æ›¸ç±ã®å†…å®¹ã‚’èª¤ã£ã¦å®Ÿè£…ã—ã¦ãŠã‚Šã€ç„¡ç†ã‚„ã‚Šå‹ã‚’ä¸€è‡´ã•ã›ã¦å‹ã‚¨ãƒ©ãƒ¼ã‚’ç„¡ãã—ã¦ã„ãŸç®‡æ‰€ã‚’æ›¸ç±ã«æ²¿ã£ãŸã‚³ãƒ¼ãƒ‰ã«ä¿®æ­£ã—ã¾ã—ãŸ

```diff ts:placeOrderWorkflow.ts
  const toAddress = (
-    unvalidatedAddress: UnvalidatedAddress
+    checkedAddress: CheckedAddress
  ): ResultAsync<Address, ValidationError> => {
-   const checkedAddress = checkAddressExistsR(unvalidatedAddress);
-
-   const result = checkedAddress.map((checkedAddress) => {
-     const mappedAddress: Address = {
-       addressLine1: checkedAddress.address.addressLine1,
-       addressLine2: checkedAddress.address.addressLine2,
-       addressLine3: checkedAddress.address.addressLine3,
-       addressLine4: checkedAddress.address.addressLine4,
-       city: checkedAddress.address.city,
-       zipCode: checkedAddress.address.zipCode,
-     };
-     return mappedAddress;
-   });
-
-   // æœ¬æ¥ã¯ã“ã“ã§returnã§è‰¯ã„ãŒã€DomainModelingã®ãƒªãƒã‚¸ãƒˆãƒªã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’ã¿ã‚‹ã¨toAddressã®å¼•æ•°ã«ã¯checkedAddressã‚’æ¸¡ã—ã¦ã„ã‚‹
-   // ãã®ãŸã‚ã€æœ¬æ¥è¿”ã™ã¹ãValidationErrorã«ç„¡ç†ã‚„ã‚Šå¤‰æ›ã—ã¦ã„ã‚‹
-   // return result;
-
-   const lierResult = result.mapErr((error) => {
-     const validationError: ValidationError = {
-       type: "error",
-       error: `${error}`,
-     };
-     return validationError;
-   });
-
-   return lierResult;
+   const result: Address = {
+     addressLine1: checkedAddress.address.addressLine1,
+     addressLine2: checkedAddress.address.addressLine2,
+     addressLine3: checkedAddress.address.addressLine3,
+     addressLine4: checkedAddress.address.addressLine4,
+     city: checkedAddress.address.city,
+     zipCode: checkedAddress.address.zipCode,
+   };
+
+   return okAsync(result);
  };
```

toAddressä»¥å¤–ã«ã‚‚é–¢é€£ç®‡æ‰€ã‚’å°‘ã—ä¿®æ­£ã—ã¦ã„ã¾ã™
å†’é ­ã«ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã«è²¼ã£ãŸæœ€çµ‚ç³»ã®ã‚³ãƒ¼ãƒ‰ãŒã“ã‚Œã«ãªã‚Šã¾ã™

https://github.com/mocchann/domain_modeling_functional/blob/main/src/placeOrderWorkflowFixToAddress.ts

ã“ã‚Œã§ã‚ˆã†ã‚„ãã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¯ä¸€é€šã‚Šæ›¸ãçµ‚ã‚ã‚Šã¾ã—ãŸ(ã“ã“ã¾ã§ã‚„ã‚‹ã®ã«ã¡ã‚‡ã†ã©3ãƒ¶æœˆã‹ã‹ã‚Šã¾ã—ãŸ)

## ã¾ã¨ã‚
æ›¸ç±ã‚’èª­ã‚“ã§ã‚³ãƒ¼ãƒ‰ã‚‚æ›¸ã„ã¦ã¿ãŸåƒ•å€‹äººæ„Ÿæƒ³ã‚’æ›¸ã„ã¦ã„ãã¾ã™

### è‰¯ã‹ã£ãŸç‚¹
- ã‚·ãƒ³ãƒ—ãƒ«ã«TypeScriptã®å‹‰å¼·ã«ãªã£ãŸ
    - bind, map, mapErrorã®è‡ªå‰å®Ÿè£…ã ã£ãŸã‚Šã€ãã‚Œã‚‰ã‚’ä½¿ã£ãŸé–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè£…ã¯ãªã‹ãªã‹ã«æ­¯å¿œãˆãŒã‚ã‚Šã¾ã—ãŸ
- æ›¸ç±ã«ç™»å ´ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ãŒGitHubã§é–²è¦§å¯èƒ½
    - æœ¬å®¶ã®ãƒªãƒã‚¸ãƒˆãƒªã¯ã“ã¡ã‚‰
        - https://github.com/swlaschin/DomainModelingMadeFunctional
- ãƒ¢ãƒŠãƒ‰ã®è€ƒãˆæ–¹ã«è§¦ã‚Œã‚‰ã‚ŒãŸ
    - ä»Šã¾ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã°ã‹ã‚Šã«è§¦ã‚Œã¦ããŸã®ã§ã€bind, mapç­‰ã‚’é§†ä½¿ã—ã¦é€£ç¶šã—ãŸä¸€é€£ã®å‡¦ç†ã‚’è¡¨ç¾ã™ã‚‹(?)ã¨ã„ã£ãŸãƒ¢ãƒŠãƒ‰ã®è€ƒãˆæ–¹ã®ä¸€ç«¯ã«è§¦ã‚Œã‚‹ã“ã¨ãŒã§ããŸã®ã¯è‰¯ã‹ã£ãŸã¨æ€ã„ã¾ã™
        - ãƒ¢ãƒŠãƒ‰ã«ã¤ã„ã¦ã¯ä»¥ä¸‹è¨˜äº‹ãŒèª­ã¿ã‚„ã™ã„ã¨æ„Ÿã˜ã¾ã—ãŸ
            - https://qiita.com/hiruberuto/items/8bbc0343bf794c368287
        - ã¡ã¾ãŸã§æµè¡Œã‚Šã¨è¨€ã‚ã‚Œã‚‹é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ä½“é¨“ã§ãã¦è‰¯ã‹ã£ãŸ
- è‡ªå‰å®Ÿè£…ã—ãŸã‚ã¨ã«neverthrowã‚’ä½¿ã£ã¦ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’ã™ã‚‹ã®ãŒæœ€é«˜ã«æ°—æŒã¡è‰¯ã„
    - ä½•ã‹å½“ãŸã‚Šå‰ã«ãªã£ã¦ã„ãŸã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®"ä¾¿åˆ©ã•"ã¨"ã‚ã‚ŠãŒãŸã•"ãŒèº«ä½“ä¸­ã«æŸ“ã¿æ¸¡ã‚Šã¾ã—ãŸ
    - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ã—ã¦ã„ã‚‹æœ€ä¸­ã€æ°—åˆ†è‰¯ã™ãã¦è„³æ±ãƒ‰ãƒãƒ‰ãƒå‡ºã¦ã¾ã—ãŸ
- æˆ¦ç•¥çš„DDDã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ããŸ
    - ä»Šå›ã®è¨˜äº‹ã¯æŠ€è¡“ã«å…¨æŒ¯ã‚Šã—ãŸå†…å®¹ã«ãªã£ã¦ã„ã¾ã™ãŒã€æ­£å‘³ã“ã£ã¡ã®å†…å®¹ãŒæœ¬è³ªã ã¨æ€ã„ã¾ã™
    - ä»Šå¾Œã€æ¥­å‹™ã‚’è¡Œã†ä¸­ã§ãƒ•ãƒ«ãƒ•ãƒ«DDDã§é–‹ç™ºã™ã‚‹ã®ã¯ãªã‹ãªã‹é›£ã—ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ãƒ“ã‚¸ãƒã‚¹ã‚µã‚¤ãƒ‰ã¨ã®ä»•æ§˜èª¿æ•´ã®ã‚„ã‚Šã¨ã‚Šã ã£ãŸã‚Šã€è¨­è¨ˆã®å ´é¢ã ã£ãŸã‚Šã§æ›¸ç±ã§ã‚­ãƒ£ãƒƒãƒã‚¢ãƒƒãƒ—ã—ãŸçŸ¥è­˜ã‚’å®Ÿè·µã—ã¦ã„ããŸã„

### èª²é¡Œãªç‚¹
- ãƒ¢ãƒŠãƒ‰ã®æ¦‚å¿µãŒæŠ½è±¡çš„ã™ãã¦æ­£ç›´ä½•ã‚‚ã‚ã‹ã£ã¦ã„ãªã„
    - ã“ã‚Œã¯æ™®æ®µé–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«è§¦ã‚Œã¦ã„ãªã„ã“ã¨ã‚‚å¤§ãã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€å…¨ä½“çš„ã«ãµã‚ã£ã¨è§¦ã‚Œã¦ã‚³ãƒ¼ãƒ‰æ›¸ã„ã¦ã¿ãŸã«ãªã£ã¦ã„ã¾ã™(æ¥­å‹™ã§æ‰±ã‚ãªã„ã®ãŒå¤§ãã„)
    - ã¾ãŸæ™‚é–“ã‚’ä½œã£ã¦Haskelã¨ã‹å…¥é–€ã—ãŸã„
- è‡ªå‰å®Ÿè£…ã®å‹ãƒ‘ã‚ºãƒ«ã«å››è‹¦å…«è‹¦ã™ã‚‹
    - æ”¹ã‚ã¦TSã‚’ã‚‚ã£ã¨å­¦ç¿’ã—ãªã„ã¨ãªã¨æ€ã„type-challengesè§¦ã£ã¦ã„ã¾ã™
- TypeScriptã§é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã™ã‚‹ã®ã¯ã‹ãªã‚Šãƒãƒ¼ãƒ‰ãƒ«ãŒé«˜ã„
    - TSã§é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€Resultå‹ã‚„safeTry, bind, mapãªã©TypeScriptã«æ¨™æº–ã§ç”¨æ„ã•ã‚Œã¦ã„ãªã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’neverthrowãªã©ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§è£œã†ã‹è‡ªå‰ã§å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ãªã‚“ã¨ã‚‚è¦‹æ…£ã‚Œãªã„æ„ŸãŒã™ã”ã„
        - ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ä¾¿åˆ©ã§è‰¯ã„ã‚‚ã®ã§ã™ãŒã€æ¨™æº–ã®TypeScriptã®æ›¸ãæ–¹ã‹ã‚‰ã¡ã‚‡ã£ã¨é€¸ã‚ŒãŸå®Ÿè£…ã‚’è¡Œã†å¿…è¦ãŒã‚ã‚‹ã®ã§ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’ã‚„ã‚‹ãªã‚‰æ›¸ç±ã§ç´¹ä»‹ã•ã‚ŒãŸF#ãªã©ã€é–¢æ•°å‹è¨€èªã‚’é¸å®šã—ãŸã»ã†ãŒè‰¯ã„ã®ã§ã¯ã¨æ€ã£ãŸã‚Šã‚‚ã—ã¾ã™
        - ã¡ãªã¿ã«ã“ã®æ„è¦‹ã¯ãƒãƒƒãƒˆã§ã¿ã‹ã‘ãŸã‚Šã€æ›¸ç±ã‚’èª­ã‚“ã äººã¨è©±ã—ãŸã‚Šã‚‚ã—ã¾ã—ãŸ

## ãŠã‚ã‚Šã«
ãƒ—ãƒ­ã‚‚ããƒãƒ£ãƒƒãƒˆAdvent Calendar 2024 8æ—¥ç›®ã¯mocchannãŒãŠå±Šã‘ã—ã¾ã—ãŸ

æ¬¡å›ã€9æ—¥ç›®@babu-chã•ã‚“ã®è¨˜äº‹ã§ã™ï¼ãŠæ¥½ã—ã¿ã«ï¼
