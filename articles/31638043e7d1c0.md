---
title: "「ドメイン駆動設計入門」「関数型ドメインモデリング」を読んでアプリを作ったので学んだことと考えをまとめた記事"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["DDD", "ドメイン駆動設計"]
published: false
---

## はじめに
DDDキャッチアップの一環で以下書籍を読み、簡単なアプリケーションを作ったので理解した内容をまとめておく

https://www.shoeisha.co.jp/book/detail/9784798150727

https://asciidwango.jp/post/754242099814268928/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0

※あくまで自分の理解・認識をまとめたものなので、間違ってるってところがあればコメントをいただけると嬉しいです🙏

書籍を読んだ上で個人開発したアプリは以下

https://github.com/mocchann/to-camp-cms

## ドメインとは
プログラムを使って問題を解決する領域のこと
例えば、会計システムの中で「消費税の計算」という問題を解決したいのであれば、消費税計算に関わる領域をドメインと呼ぶことになる

## ドメイン駆動設計とは
ドメインの知識に焦点を当てた設計手法のこと
また、ソフトウェアが責務を全うするために必要な知識を元に、事象や概念を抽象化する作業をモデリングと言う
モデリングの結果できた成果物をドメインモデルという
ドメインモデルは、ドメインのある特定の側面を表現したもので、現実世界のドメインをそのまま表したものではない
ドメインモデルを作成してすぐは「仮」の状態であり、実際に使ってみるまではドメインモデルが正しいかどうかは判断できない
そのため、ドメインモデリングしたあとにコードに落とし込み実際に使ってみる必要がある
そこで出た改善点を元にドメインモデルを更新していくというサイクルを回すことで、ソフトウェアの利用者を取り巻く世界と実装を結びつけることがドメイン駆動設計の目的である

## 戦略的DDDとは
ソフトウェアシステム全体を俯瞰して、大規模な構造をどのように分割・整理し、それらの関係性をどう定義するか、といったマクロな視点での設計手法のこと
設計の流れとしては以下のような手順で進める

1. 開発者とドメインエキスパートが集まり、イベントストーミングによってドメインを可視化する
2. ドメインをより小さいサブドメインに分割する
3. 分割したサブドメインをもとに境界づけられたコンテキストを定義する
4. コンテキストマップを作成して、境界づけられたコンテキストがどのように相互作用するかの全体像を把握する
5. 開発者とドメインエキスパートの認識のズレを防ぐために、ユビキタス言語(関係者全員が共通して使用する言語)を定義する
6. できあがった全体像(ワークフロー)を元に詳細をドメインエキスパートと一緒に詰めていく
7. 複雑さをドメインモデルで表現する
8. アーキテクチャ設計をして、実装に入っていく

## 戦術的DDDとは
境界づけられたコンテキスト内部でドメインモデルをどのようにコードで表現するか、といったミクロ視点での設計手法のこと
戦術的DDDのパターンのみを取り入れることを「軽量DDD」と言われ、本質から離れてHowに寄ることでドメインを見失いがちなことからアンチパターンと言われる
主に以下の概念を用いる

### 値オブジェクト
以下の性質を持つオブジェクトのこと

#### 識別子を持たない
エンティティは属性が変わっても同一性を保つために識別子(ID)を持つが、値オブジェクトは識別子を持たない
オブジェクトが持つ属性の値の組み合わせ自体が、値オブジェクトを定義する

e.g. キャンプ場の立地条件(海・山・川などの立地条件のenumを持つ値オブジェクト)

```php
<?php

namespace App\Domain\Models\CampGrounds;

use App\Domain\Enums\CampGroundLocations as EnumsCampGroundLocations;
use InvalidArgumentException;
use ValueError;

class CampGroundLocation
{
    private EnumsCampGroundLocations $camp_ground_location;

    public function __construct(
        private string $location
    ) {
        try {
            $this->camp_ground_location = EnumsCampGroundLocations::from($location);
        } catch (ValueError $e) {
            throw new InvalidArgumentException('Invalid location', $e->getMessage());
        }
    }

    public function getValue(): EnumsCampGroundLocations
    {
        return $this->camp_ground_location;
    }
}
```

#### 不変であること

#### 等価交換・比較が可能

#### ライフサイクルを持たない

#### 1度作ったあとに値の変更は不可

### エンティティとは
ライフサイクルのあるオブジェクト
等価交換不可
一意性のあるオブジェクト
ユニークな識別子を持つ

### ドメインサービス
エンティティに持つと不自然な処理を書くドメインのためのサービス
あくまでエンティティに実装するのが不自然な処理がある場合にのみ、ドメインサービスを用いる
積極的には使わない→なんでもかんでもドメインサービスに処理を書いてしまう→ドメインモデル貧血症になりやすいので注意

### リポジトリ
データストアへの永続化をドメインと責務分離するためのclass
interfaceを挟み依存性を逆転することでアプリケーションに柔軟性を持たせることができる

### アプリケーションサービス
いわゆるユースケース
executeなどただひとつの実行メソッドを持つ
リポジトリに依存し、ドメインオブジェクトをデータストアへ永続化する役割を担う

### ファクトリ
複雑な処理等の責務を分離するためのclass

### コマンドオブジェクト
引数が数多くあるときに、修正箇所が増えてしまうためそれを解決するオブジェクト？
コマンドの責務をこのオブジェクトで吸収することにより、引数が更新されるときなどもコマンドオブジェクトにまとめられているのでこのオブジェクトをいじればよくなり保守性があがる

### 集約
データストアへの永続化の単位？
たとえば社員集約と、所属部署集約があるとすれば、それぞれ別々にデータストアへ永続化する
SQLのcascade deleteとかをイメージすると理解しやすいかも？

### 仕様
？？？
