---
title: "「ドメイン駆動設計入門」「関数型ドメインモデリング」を読んでアプリを作ったので学んだことと考えをまとめた記事"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["DDD", "ドメイン駆動設計"]
published: false
---

## はじめに

DDDキャッチアップの一環で以下書籍を読み、簡単なアプリケーションを作ったので理解した内容をまとめておく

https://www.shoeisha.co.jp/book/detail/9784798150727

https://asciidwango.jp/post/754242099814268928/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0

※あくまで自分の理解・認識をまとめたものなので、間違ってるってところがあればコメントをいただけると嬉しいです🙏

書籍を読んだ上で個人開発したアプリは以下

https://github.com/mocchann/to-camp-cms

## ドメインとは

プログラムを使って問題を解決する領域のこと
例えば、会計システムの中で「消費税の計算」という問題を解決したいのであれば、消費税計算に関わる領域をドメインと呼ぶことになる

## ドメイン駆動設計とは

ドメインの知識に焦点を当てた設計手法のこと
また、ソフトウェアが責務を全うするために必要な知識を元に、事象や概念を抽象化する作業をモデリングと言う
モデリングの結果できた成果物をドメインモデルという
ドメインモデルは、ドメインのある特定の側面を表現したもので、現実世界のドメインをそのまま表したものではない
ドメインモデルを作成してすぐは「仮」の状態であり、実際に使ってみるまではドメインモデルが正しいかどうかは判断できない
そのため、ドメインモデリングしたあとにコードに落とし込み実際に使ってみる必要がある
そこで出た改善点を元にドメインモデルを更新していくというサイクルを回すことで、ソフトウェアの利用者を取り巻く世界と実装を結びつけることがドメイン駆動設計の目的である

## 戦略的DDDとは

ソフトウェアシステム全体を俯瞰して、大規模な構造をどのように分割・整理し、それらの関係性をどう定義するか、といったマクロな視点での設計手法のこと
設計の流れとしては以下のような手順で進める

1. 開発者とドメインエキスパートが集まり、イベントストーミングによってドメインを可視化する
2. ドメインをより小さいサブドメインに分割する
3. 分割したサブドメインをもとに境界づけられたコンテキストを定義する
4. コンテキストマップを作成して、境界づけられたコンテキストがどのように相互作用するかの全体像を把握する
5. 開発者とドメインエキスパートの認識のズレを防ぐために、ユビキタス言語(関係者全員が共通して使用する言語)を定義する
6. できあがった全体像(ワークフロー)を元に詳細をドメインエキスパートと一緒に詰めていく
7. 複雑さをドメインモデルで表現する
8. アーキテクチャ設計をして、実装に入っていく

## 戦術的DDDとは

境界づけられたコンテキスト内部でドメインモデルをどのようにコードで表現するか、といったミクロ視点での設計手法のこと
戦術的DDDのパターンのみを取り入れることを「軽量DDD」と言われ、本質から離れてHowに寄ることでドメインを見失いがちなことからアンチパターンと言われる
主に以下の概念を用いる

### 値オブジェクト

ドメインにおける「値」を表すオブジェクトのこと

e.g. キャンプ場の立地条件(海・山・川などの立地条件のenumを持つ値オブジェクト)

```php
<?php

namespace App\Domain\Models\CampGrounds;

use App\Domain\Enums\CampGroundLocations as EnumsCampGroundLocations;
use InvalidArgumentException;
use ValueError;

class CampGroundLocation
{
    private EnumsCampGroundLocations $camp_ground_location;

    public function __construct(
        private string $location
    ) {
        try {
            $this->camp_ground_location = EnumsCampGroundLocations::from($location);
        } catch (ValueError $e) {
            throw new InvalidArgumentException('Invalid location', $e->getMessage());
        }
    }

    public function getValue(): EnumsCampGroundLocations
    {
        return $this->camp_ground_location;
    }
}
```


#### 識別子を持たない

エンティティは属性が変わっても同一性を保つために識別子(ID)を持つが、値オブジェクトはエンティティとは対照的で識別子を持たない
オブジェクトが持つ属性の値の組み合わせ自体が値オブジェクトを定義する

#### 不変であること

一度作成された値オブジェクトの状態は変更できない
もし、値を変える必要がある場合は、新しい値を持つ別のインスタンスを作成する
こうすることで意図しない副作用を防ぎ、オブジェクトの状態を予測可能で安全に保つことができる

#### 置き換えが可能

値オブジェクトの状態を更新する場合は、古いインスタンスを破棄し新しい値を持つインスタンスで「置き換える」ことになる
値そのものが変われば別物として扱う

#### 独自ライフサイクルを持たない

必要に応じて作成され、不要になれば参照が外れてガベージコレクションの対象となる
エンティティは生成から変更、削除までのライフサイクルを持つため、エンティティのようにそれ自体が追跡・管理される対象にはならない

#### 自己検証ロジックを持つ

生成される際に自身の属性値が有効であるかを検証するロジックを持つことが推奨される

#### なぜ値オブジェクトを使うのか

ドメインの表現力向上: プリミティブ型をそのまま使うよりも、ドメインの概念を明確にコード場で表現できる
コードの明確化・凝集度向上: 値に関するロジック(検証、比較、計算など)を値オブジェクト内にカプセル化することで関連するコードがまとまる
不変性による安全性: 状態が変わらないため、予期しない副作用が起こりにくく、安全に扱うことができる
再利用性: ドメイン内で共通の「値」の概念を複数箇所で再利用できる

### エンティティとは
ライフサイクルのあるオブジェクト
等価交換不可
一意性のあるオブジェクト
ユニークな識別子を持つ

### ドメインサービス
エンティティに持つと不自然な処理を書くドメインのためのサービス
あくまでエンティティに実装するのが不自然な処理がある場合にのみ、ドメインサービスを用いる
積極的には使わない→なんでもかんでもドメインサービスに処理を書いてしまう→ドメインモデル貧血症になりやすいので注意

### リポジトリ
データストアへの永続化をドメインと責務分離するためのclass
interfaceを挟み依存性を逆転することでアプリケーションに柔軟性を持たせることができる

### アプリケーションサービス
いわゆるユースケース
executeなどただひとつの実行メソッドを持つ
リポジトリに依存し、ドメインオブジェクトをデータストアへ永続化する役割を担う

### ファクトリ
複雑な処理等の責務を分離するためのclass

### コマンドオブジェクト
引数が数多くあるときに、修正箇所が増えてしまうためそれを解決するオブジェクト？
コマンドの責務をこのオブジェクトで吸収することにより、引数が更新されるときなどもコマンドオブジェクトにまとめられているのでこのオブジェクトをいじればよくなり保守性があがる

### 集約
データストアへの永続化の単位？
たとえば社員集約と、所属部署集約があるとすれば、それぞれ別々にデータストアへ永続化する
SQLのcascade deleteとかをイメージすると理解しやすいかも？

### 仕様
？？？
